// ChatPage.test.js
import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import ChatPage from './page'; // Assumindo que o arquivo se chama 'page.jsx'

// --- Mocks Globais ---

/**
 * Helper para criar um token JWT falso com um payload específico.
 * A função 'atob' do componente precisa disso para 'getUserIdFromToken'.
 */
const FAKE_USER_ID = 'user-123';
const createFakeToken = (userId) => {
  // Simula o formato header.payload.signature
  const payload = JSON.stringify({ nameid: userId });
  // btoa está disponível no ambiente de teste jsdom
  return `header.${btoa(payload)}.signature`;
};
const FAKE_TOKEN = createFakeToken(FAKE_USER_ID);

/**
 * Mock do window.localStorage e sessionStorage.
 * O componente usa isso para 'getAuthToken'.
 */
let localStorageStore = {};
const mockLocalStorage = {
  getItem: jest.fn((key) => localStorageStore[key] || null),
  setItem: jest.fn((key, value) => {
    localStorageStore[key] = value.toString();
  }),
  clear: jest.fn(() => {
    localStorageStore = {};
  }),
};
// Simula localStorage e sessionStorage apontando para o mesmo mock
Object.defineProperty(window, 'localStorage', { value: mockLocalStorage });
Object.defineProperty(window, 'sessionStorage', { value: mockLocalStorage });

/**
 * Mock do window.location.
 * O componente redireciona (window.location.href) se não houver token.
 */
Object.defineProperty(window, 'location', {
  writable: true,
  value: { href: '' },
});

/**
 * Mock da API 'fetch' global.
 */
global.fetch = jest.fn();

/**
 * Mock do componente Navbar.
 */
jest.mock('../../components/Navbar', () => {
  return function DummyNavbar() {
    return <div data-testid="navbar-mock">Navbar</div>;
  };
});

/**
 * Mock do 'scrollIntoView' para o 'messagesEndRef'.
 */
window.HTMLElement.prototype.scrollIntoView = jest.fn();

/**
 * Mock avançado da biblioteca @microsoft/signalr.
 * Precisamos simular o padrão "builder" e a conexão
 * que retorna métodos 'on', 'start' e 'stop'.
 */
const mockSignalRConnection = {
  // Armazena os callbacks (ex: 'ReceiveMessage') para que possamos chamá-los
  handlers: new Map(),
  on: jest.fn((eventName, callback) => {
    mockSignalRConnection.handlers.set(eventName, callback);
  }),
  start: jest.fn(() => Promise.resolve()),
  stop: jest.fn(() => Promise.resolve()),
  onreconnecting: jest.fn(),
  onreconnected: jest.fn(),
  onclose: jest.fn(),
};

jest.mock('@microsoft/signalr', () => ({
  HubConnectionBuilder: jest.fn(() => ({
    withUrl: jest.fn(() => ({
      withAutomaticReconnect: jest.fn(() => ({
        configureLogging: jest.fn(() => ({
          build: jest.fn(() => mockSignalRConnection), // Retorna nossa conexão mockada
        })),
      })),
    })),
  })),
  HttpTransportType: { WebSockets: 1 },
  LogLevel: { Information: 1 },
}));

/**
 * Função helper para simular o recebimento de uma mensagem via SignalR.
 * Ela encontra o handler 'ReceiveMessage' e o invoca.
 */
const simulateSignalRMessage = (message) => {
  // O componente registra em 4 eventos diferentes, vamos chamar todos
  const handlers = [
    mockSignalRConnection.handlers.get('ReceiveMessage'),
    mockSignalRConnection.handlers.get('NewMessage'),
    mockSignalRConnection.handlers.get('MessageReceived'),
    mockSignalRConnection.handlers.get('OnMessageReceived'),
  ];

  act(() => {
    handlers.forEach(handler => {
      if (handler) handler(message);
    });
  });
};

// --- Dados de Mock ---

const mockConversation1 = {
  conversationId: 'conv-1',
  otherUserName: 'Jorge Dev',
  otherUserId: 'jorge-456',
  lastMessage: 'Olá, tudo bem?',
  lastMessageDate: new Date().toISOString(),
  unreadMessagesCount: 1,
};

const mockConversation2 = {
  conversationId: 'conv-2',
  otherUserName: 'Maria Prestadora',
  otherUserId: 'maria-789',
  lastMessage: 'Serviço confirmado.',
  lastMessageDate: new Date().toISOString(),
  unreadMessagesCount: 0,
};

const mockMessages = [
  { id: 'm1', senderId: 'jorge-456', content: 'Olá, tudo bem?', sentAt: new Date().toISOString(), isRead: true },
  { id: 'm2', senderId: FAKE_USER_ID, content: 'Tudo ótimo!', sentAt: new Date().toISOString(), isRead: true },
];

// --- Suíte de Testes Principal ---

describe('ChatPage', () => {
  /**
   * Ativa os timers falsos do Jest para controlar 'setInterval'.
   */
  beforeAll(() => {
    jest.useFakeTimers();
  });

  /**
   * Limpa todos os mocks antes de cada teste.
   */
  beforeEach(() => {
    jest.clearAllMocks();
    mockLocalStorage.clear();
    global.fetch.mockReset();
    mockSignalRConnection.handlers.clear();

    // Resposta padrão do fetch para evitar erros
    global.fetch.mockResolvedValue({
      ok: true,
      json: async () => ({}),
    });
  });

  afterAll(() => {
    jest.useRealTimers(); // Restaura timers reais
  });

  /**
   * Helper para renderizar e avançar timers de polling
   */
  const renderAndWait = async (token = FAKE_TOKEN) => {
    if (token) {
      mockLocalStorage.setItem('auth_token', token);
    }
    render(<ChatPage />);
    // Avança os timers para disparar os 'setInterval' e 'setTimeout'
    await act(async () => {
      jest.advanceTimersByTime(5000); 
    });
  };

  // --- Testes ---

  it('1. deve redirecionar para /auth/login se não houver token', () => {
    render(<ChatPage />); // Renderiza sem token no localStorage
    expect(window.location.href).toBe('/auth/login');
  });

  it('2. deve carregar e exibir a lista de conversas', async () => {
    // Configura o fetch para /conversations
    global.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => [mockConversation1, mockConversation2],
    });

    await renderAndWait();

    // Verifica se a API de conversas foi chamada
    expect(global.fetch).toHaveBeenCalledWith(
      'https://api.desenrola.shop/api/Message/conversations',
      expect.any(Object)
    );

    // Verifica se as conversas apareceram
    expect(await screen.findByText('Jorge Dev')).toBeInTheDocument();
    expect(screen.getByText('Maria Prestadora')).toBeInTheDocument();
    
    // Verifica o contador de não lidas
    expect(screen.getByText('1')).toBeInTheDocument();
  });

  it('3. deve conectar ao SignalR após autenticar', async () => {
    global.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => [],
    });
    
    await renderAndWait();

    // Verifica se a conexão SignalR foi iniciada
    expect(mockSignalRConnection.start).toHaveBeenCalled();
  });

  it('4. deve selecionar uma conversa, buscar e exibir o histórico de mensagens', async () => {
    // 1. Fetch de Conversas
    global.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => [mockConversation1],
    });
    
    // 2. Fetch do Histórico (quando o usuário clicar)
    global.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockMessages,
    });
    
    // 3. Fetch de MarkAsRead (porque a conv1 tem 1 não lida)
    global.fetch.mockResolvedValueOnce({ ok: true });
    
    // 4. Fetch de Conversas (depois do markAsRead)
    global.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => [{ ...mockConversation1, unreadMessagesCount: 0 }],
    });

    await renderAndWait();

    // Encontra a conversa e clica nela
    const conversationItem = await screen.findByText('Jorge Dev');
    fireEvent.click(conversationItem);

    // Verifica se o histórico foi buscado
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledWith(
        'https://api.desenrola.shop/api/Message/conversation/conv-1/history',
        expect.any(Object)
      );
    });

    // Verifica se as mensagens apareceram
    expect(await screen.findByText('Olá, tudo bem?')).toBeInTheDocument();
    expect(screen.getByText('Tudo ótimo!')).toBeInTheDocument();

    // Verifica se marcou como lida
    expect(global.fetch).toHaveBeenCalledWith(
      'https://api.desenrola.shop/api/Message/conversation/conv-1/mark-as-read',
      expect.objectContaining({ method: 'PUT' })
    );

    // Verifica se o contador de não lidas '1' sumiu
    await waitFor(() => {
      expect(screen.queryByText('1')).not.toBeInTheDocument();
    });
  });

  it('5. deve enviar uma mensagem (pressionando Enter)', async () => {
    const FAKE_SENT_MESSAGE = {
      id: 'm3',
      senderId: FAKE_USER_ID,
      content: 'Mensagem de teste!',
      sentAt: new Date().toISOString(),
      isRead: false
    };

    // 1. Fetch de Conversas
    global.fetch.mockResolvedValueOnce({ ok: true, json: async () => [mockConversation1] });
    // 2. Fetch do Histórico
    global.fetch.mockResolvedValueOnce({ ok: true, json: async () => mockMessages });
    // 3. Fetch de MarkAsRead
    global.fetch.mockResolvedValueOnce({ ok: true });
    // 4. Fetch de Conversas (pós-leitura)
    global.fetch.mockResolvedValueOnce({ ok: true, json: async () => [{ ...mockConversation1, unreadMessagesCount: 0 }] });

    await renderAndWait();

    // Seleciona a conversa
    fireEvent.click(await screen.findByText('Jorge Dev'));
    await screen.findByText('Tudo ótimo!'); // Espera o chat carregar

    // 5. Mock do 'fetch' para /api/Message/send
    global.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => FAKE_SENT_MESSAGE,
    });
    // 6. Mock do 'fetch' para /conversations (que é chamado após o send)
    global.fetch.mockResolvedValueOnce({ ok: true, json: async () => [] });


    // Encontra o input e digita
    const input = screen.getByPlaceholderText('Escreva sua mensagem');
    await userEvent.type(input, 'Mensagem de teste!');

    // Envia pressionando Enter
    fireEvent.keyPress(input, { key: 'Enter', code: 'Enter', charCode: 13 });

    // Verifica se a API de envio foi chamada
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledWith(
        'https://api.desenrola.shop/api/Message/send',
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify({
            receiverId: mockConversation1.otherUserId, // 'jorge-456'
            content: 'Mensagem de teste!',
          }),
        })
      );
    });
    
    // Verifica se o input foi limpo
    expect(input.value).toBe('');
    
    // Verifica se a mensagem enviada apareceu no chat
    expect(await screen.findByText('Mensagem de teste!')).toBeInTheDocument();
  });

  it('6. deve receber uma nova mensagem via SignalR', async () => {
    const SIGNALR_MESSAGE = {
      id: 'm-signalr',
      senderId: 'jorge-456', // ID do 'otherUser'
      content: 'Mensagem via SignalR!',
      sentAt: new Date().toISOString(),
      isRead: false
    };

    // 1. Fetch de Conversas
    global.fetch.mockResolvedValueOnce({ ok: true, json: async () => [mockConversation1] });
    // 2. Fetch do Histórico
    global.fetch.mockResolvedValueOnce({ ok: true, json: async () => mockMessages });
    // 3. Fetch de MarkAsRead
    global.fetch.mockResolvedValueOnce({ ok: true });
    // 4. Fetch de Conversas (pós-leitura)
    global.fetch.mockResolvedValueOnce({ ok: true, json: async () => [{ ...mockConversation1, unreadMessagesCount: 0 }] });
    
    await renderAndWait();
    
    // Seleciona a conversa
    fireEvent.click(await screen.findByText('Jorge Dev'));
    await screen.findByText('Tudo ótimo!'); // Espera o chat carregar

    // 5. Mock do fetch de 'conversations' (que é chamado pelo handler do SignalR)
    global.fetch.mockResolvedValueOnce({ ok: true, json: async () => [] });

    // Simula a mensagem chegando
    simulateSignalRMessage(SIGNALR_MESSAGE);

    // Verifica se a nova mensagem apareceu
    expect(await screen.findByText('Mensagem via SignalR!')).toBeInTheDocument();
    
    // Verifica se o 'fetchConversations' foi chamado (pelo 'setTimeout' no handler)
    await act(async () => {
      jest.advanceTimersByTime(500); // Avança o setTimeout de 500ms
    });
    expect(global.fetch).toHaveBeenCalledWith(
      'https://api.desenrola.shop/api/Message/conversations',
      expect.any(Object)
    );
  });
});